---
title: "RT Session 1"
format:
  revealjs: 
    scrollable: true
    multiplex: true
    preview-links: auto
    logo: img/rt-logo.webp
    css: styles.css
    gfm:
      mermaid-format: svg
---

# Hello

# Icebreaker

## Do you recognize the logo?

![](img/logotest.png){width=100%}

## Shout it Out!

![](img/logotest.png){width=100%}


## About Spotify

::: incremental

- 626 million active users globally.
- Over 100 million songs in the Spotify library.
- Detailed metadata for each song, including artist, album, release date, Beats per minute, danceability, valence, energy, liveness etc
- In our current project, we will explore the 2023 Spotify Dataset.
- This dataset contains 953 rows and 16 columns.
:::




## Dataset {.smaller}


```{r}
library(readr)
library(DT)
data_r <- read_csv("spotify2023.csv", show_col_types = FALSE)
datatable(data_r, options = list(scrollX = TRUE, scrollY = "300px"))
```

::: {.fragment .fade-in}

Let's understand the column one-by-one.

:::

## Column Explanation


::: {.fragment .fade-in-then-semi-out}

track_name: Name of the song
:::

::: {.fragment .fade-in-then-semi-out}

artist(s)_name: Name of the artist(s) of the song
:::

::: {.fragment .fade-in-then-semi-out}

artist_count: Number of artists contributing to the song
:::

::: {.fragment .fade-in-then-semi-out}

released_year: Year when the song was released
:::

::: {.fragment .fade-in-then-semi-out}

released_month: Month when the song was released

:::

::: {.fragment .fade-in-then-semi-out}

released_day: Day of the month when the song was released
:::

::: {.fragment .fade-in-then-semi-out}
streams: Total number of streams on Spotify
:::

::: {.fragment .fade-in-then-semi-out}
bpm: Beats per minute, a measure of song tempo
:::

::: {.fragment .fade-in-then-semi-out}

mode: Mode of the song (major or minor)
:::


## Column Explanation (cont.)

::: {.fragment .fade-in-then-semi-out}
danceability_%: Percentage indicating how suitable the song is for dancing
:::

::: {.fragment .fade-in-then-semi-out}
valence_%: Positivity of the song's musical content
:::

::: {.fragment .fade-in-then-semi-out}
energy_%: Perceived energy level of the song
:::

::: {.fragment .fade-in-then-semi-out}
acousticness_%: Amount of acoustic sound in the song
:::

::: {.fragment .fade-in-then-semi-out}
instrumentalness_%: Amount of instrumental content in the song
:::

::: {.fragment .fade-in-then-semi-out}
liveness_%: Presence of live performance elements
:::

::: {.fragment .fade-in-then-semi-out}
speechiness_%: Amount of spoken words in the song
:::


## Given this dataset, what are some questions that Spotify might ask to understand its users / improve its platform? {.smaller}


```{r}
library(readr)
library(DT)
data_r <- read_csv("spotify2023.csv", show_col_types = FALSE)
datatable(data_r, options = list(scrollX = TRUE, scrollY = "300px"))
```


## Questions that Spotify might be interested in

::: incremental

- What are the top 5 songs in 2023? 
- What are the characteristics of the top 5 songs?
- What are the months and days that most songs are produced?
- What are the distributions of the audio features?
- What are the relationship between audio features?
- What are the different characteristics between the most and least-stream songs?

:::

# IT IS HARD TO ANSWER THOSE QUESTIONS BY JUST LOOKING AT IT

::: {.fragment .fade-in}

Therefore, we visualize the data to extract useful insights.
:::



## Exploratory Data Analysis

::: {.fragment .fade-in-then-semi-out}
Exploratory Data Analysis (EDA) is the process of analyzing data sets to summarize their main characteristics, often using visual methods.
:::

::: {.fragment .fade-in-then-semi-out}
It’s a critical step in the data analysis workflow, providing insights into the structure, patterns, and relationships within the data.
:::


## Exploratory Data Analysis

::: incremental

- EDA helps you to **understand the nuances in your data**
- EDA helps **ensure the quality and reliability of your data**
- EDA is the **foundation** for complex analyses as it helps with features selection, hypothesis generation, and determining the research direction. 
:::

## Agenda

::: incremental
- Table Analysis
- Discrete Data Analysis
- Continuous Data Analysis
- Trend Analysis
- Relationship Analysis
:::


# (1) Table Analysis


## What are the top 5 songs based on stream in 2023?{.smaller}

```{r}
library(readr)
library(DT)
data_r <- read_csv("spotify2023.csv", show_col_types = FALSE)
datatable(data_r, options = list(scrollX = TRUE, scrollY = "300px"))
```


## What are the top 5 songs based on danceability in 2023?{.smaller}

```{r}
library(readr)
library(DT)
data_r <- read_csv("spotify2023.csv", show_col_types = FALSE)
datatable(data_r, options = list(scrollX = TRUE, scrollY = "300px"))
```

## What are the bottom 5 songs based on energy in 2023? {.smaller}

```{r}
library(readr)
library(DT)
data_r <- read_csv("spotify2023.csv", show_col_types = FALSE)
datatable(data_r, options = list(scrollX = TRUE, scrollY = "300px"))
```


# (2) Discrete Feature Analysis

## Discrete Feature

::: {.fragment .fade-in-then-semi-out}
Features that can only take in a specific set of values, often counted in whole number. For example, 
:::

::: incremental
- Coin flips: 0 or 1
- Days of the Week: Monday, Tuesday, Wednesday etc
- Class Grades: Students can receive specific grades like A, B, C, D, or F.
:::


## Bar Plot

::: {.fragment .fade-in-then-semi-out}
A bar plot is a chart that uses bars to represent the frequency or count of different categories of a discrete variable.
:::

::: {.fragment .fade-in-then-semi-out}
Bar plots are ideal for discrete variables because they clearly show the count or frequency of each category, making it easy to compare them.
:::

## Bar Plot Analysis

::: {.callout-tip appearance="simple"}
Select a categorical column to visualize:
```{ojs}
data = FileAttachment("spotify2023.csv").csv({ typed: true })
cat_columns = ['released_month', 'released_day','mode']
viewof selected_column_cat = Inputs.radio(cat_columns, {value: cat_columns[0]})
```
:::


```{ojs}
grouped_data = d3.groups(data, d => d[selected_column_cat]).map(([key, values]) => ({key, count: values.length}));

Plot.plot({
  marks: [
    Plot.barY(grouped_data, {x: "key", y: "count", fill: "steelblue"}),
    Plot.text(grouped_data, {x: "key", y: "count", text: d => d.count, dy: -10})
  ],
  x: {
    label: selected_column_cat
  },
  y: {
    label: "Count"
  },
  color: {
    legend: false
  }
})
```

## What did you observe in the count of years and months?


# (3) Continuous Feature Analysis

## Continuous Feature

::: {.fragment .fade-in-then-semi-out}
Features that can take any value within a given range, often measured and including fractions or decimals.
:::

::: incremental
- Height: A person’s height can be any value within a range (e.g., 150.5 cm, 170.2 cm).
- Temperature: Temperature can vary continuously (e.g., 22.3°C, 35.6°C).
- Weight: Weight can take on any value within a range (e.g., 55.5 kg, 72.8 kg).
:::

## Histogram

::: {.fragment .fade-in-then-semi-out}
A histogram is a chart that uses bars to represent the distribution of a continuous variable, showing the frequency of data within certain ranges or bins.
:::

::: {.fragment .fade-in-then-semi-out}
Histogram makes it easier to identify patterns, such as skewness, central tendency, and the presence of outliers.
:::

## Histogram Analysis {.smaller}

::: {.callout-tip appearance="simple"}
Select a continuous column to visualize:
```{ojs}
cont_columns = ['streams', 'bpm', 'danceability_%', 'valence_%', 'energy_%', 'acousticness_%',
       'instrumentalness_%', 'liveness_%', 'speechiness_%']
viewof selected_column = Inputs.radio(cont_columns, {value: 'danceability_%'})
viewof bin_count = Inputs.range([1, 50], {step: 1, value: 15, label: "Number of Bins"})

```
:::


```{ojs}
Plot.plot({
  marks: [
    Plot.rectY(data, Plot.binX({y: "count"}, {x: selected_column, fill: "steelblue", thresholds: bin_count}))
  ],
  x: {
    label: selected_column
  },
  y: {
    label: "Count"
  },
  color: {
    legend: false
  }
})
```

## What happened when you increase/decrease the number of bins?


## What happened when you increase/decrease the number of bins?

::: {.fragment .fade-in-then-semi-out}
- **Increasing bins**: Provides a more detailed and granular view of the data, revealing smaller variations in the distribution.
:::

::: {.fragment .fade-in-then-semi-out}
- **Decreasing bins**: Offers a broader, smoother overview of the data, potentially hiding finer details but simplifying the overall pattern.
:::

## What did you observe from the barplot itself

[fix comment for utteranc]{style="color:red;"}

<div class="utterances-comments">
{{< utterances-comments >}}
</div>

# (4) Trend Analysis

## About Trend Analysis

::: {.fragment .fade-in-then-semi-out}
Trend analysis is the process of examining data over time to identify patterns, trends, and insights. 
:::

## Why is trend analysis important for Spotify?

[fix comment for utteranc]{style="color:red;"}

<div class="utterances-comments">
{{< utterances-comments >}}
</div>

## Understanding Trends for Spotify

::: incremental
- **Understanding Audience Preferences:** Analyzing music feature trends over time helps identify shifts in listener preferences, enabling better music recommendations and targeted marketing strategies.

- **Predicting Hits:** By recognizing trends in features like danceability or energy, Spotify can anticipate which songs might become popular, aiding in playlist curation and promotional efforts.

- **Adapting to Industry Changes:** Monitoring trends allows Spotify to stay aligned with evolving music genres and production styles, ensuring its catalog remains relevant and appealing to users.
:::


## Visualize


::: {.callout-tip appearance="simple"}
Select a continuous column to visualize:
```{ojs}
audio_features = ['danceability_%', 'valence_%', 'energy_%', 'acousticness_%',
                  'instrumentalness_%', 'liveness_%', 'speechiness_%']
viewof selected_column_trend = Inputs.radio(audio_features, {value: 'danceability_%'})

// Group the data by 'released_year' and calculate the mean of the audio features
trends = Array.from(
  d3.group(data, d => d.released_year),
  ([released_year, group]) => ({
    released_year,
    ...Object.fromEntries(audio_features.map(feature => [
      feature,
      d3.mean(group, d => d[feature])
    ]))
  })
)

```
:::


```{ojs}
sorted_trends = trends.sort((a, b) => a.released_year - b.released_year)

// Create the line plot with the sorted data
Plot.line(sorted_trends, {x: 'released_year', y: selected_column_trend}).plot()
```

## What did you observe from the trend analysis?

[fix comment for utteranc]{style="color:red;"}

<div class="utterances-comments">
{{< utterances-comments >}}
</div>


# (5) Relationship Analysis


## Scatterplot

::: incremental
- A scatterplot is a type of data visualization that displays individual data points on a two-dimensional graph.
- Each point on the scatterplot represents an observation from a dataset, with its position determined by two variables—one plotted on the x-axis and the other on the y-axis.
- Scatterplots are commonly used to explore the relationship between two continuous variables to reveal patterns, trends, correlations, or clusters within the data.
:::

## Linear Regression

::: incremental
- **Linear regression** is a statistical method used to model and analyze the relationship between two variables by fitting a linear equation to the observed data.
:::

## Linear Regression

::: incremental
- The linear equation is typically of the form: $y = mx + c$, where:

  - $y$  is the dependent variable (the outcome we are trying to predict or explain),
  - $x$  is the independent variable (the predictor or input variable),
  - $m$   is the slope of the line (indicating the change in $y$ for a unit change in $x$).
  - $c$  is the y-intercept (the value of $y$ when $x$ is 0).
:::



## Linear Regression

::: {.fragment .fade-in-then-semi-out}
Linear regression helps quantify the strength and direction (positive or negative) of the relationship between the variables.
:::



## Visualization {.smaller}

::: columns
::: {.column width="30%"}

::: {.callout-tip appearance="simple"}
Select a $x$ column to visualize:
```{ojs}
bivariate_cont_columns = ['danceability_%', 'valence_%', 'energy_%', 'acousticness_%',
                  'instrumentalness_%', 'liveness_%', 'speechiness_%', 'streams']

// Create the radio inputs for selecting X and Y axis columns
viewof x_column = Inputs.radio(bivariate_cont_columns, {value: 'danceability_%'})
```
:::

::: {.callout-tip appearance="simple"}
Select a $y$ column to visualize:
```{ojs}
viewof y_column = Inputs.radio(bivariate_cont_columns, {value: 'streams'})
```
:::

:::


::: {.column width="70%"}
```{ojs}
// Create the scatterplot with a linear regression line
Plot.plot({
  marks: [
    Plot.dot(data, {x: x_column, y: y_column, fill: "#1E2F97", fillOpacity: 0.5}),
    Plot.linearRegressionY(data, {x: x_column, y: y_column, stroke: "red"})
  ]
})
```
:::
:::


## Correlation

::: incremental
- **Correlation** measures how two things are related to each other, like how one changes when the other does.
- **Positive correlation** means as one thing increases, the other also increases (e.g., more study time, better grades).
- **Negative correlation** means as one thing increases, the other decreases (e.g., more exercise, lower stress).
:::

## Correlation Heatmap {.smaller}

::: {.callout-tip appearance="simple"}
Select Continuous Variables for Correlation Heatmap:
```{ojs}
viewof selected_bivariate_cont_columns = Inputs.checkbox(bivariate_cont_columns, {value: bivariate_cont_columns})
```
:::


```{ojs}
function calculateCorrelationMatrix(data, selectedColumns) {
  const n = selectedColumns.length;
  const correlationMatrix = Array.from({ length: n }, () => Array(n).fill(0));

  function pearsonCorrelation(x, y) {
    const meanX = d3.mean(x);
    const meanY = d3.mean(y);
    const diffX = x.map(d => d - meanX);
    const diffY = y.map(d => d - meanY);
    const numerator = d3.sum(diffX.map((d, i) => d * diffY[i]));
    const denominator = Math.sqrt(d3.sum(diffX.map(d => d * d)) * d3.sum(diffY.map(d => d * d)));
    return numerator / denominator;
  }

  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      const col1 = selectedColumns[i];
      const col2 = selectedColumns[j];
      const values1 = data.map(d => d[col1]);
      const values2 = data.map(d => d[col2]);
      const correlation = pearsonCorrelation(values1, values2);
      correlationMatrix[i][j] = correlation;
    }
  }

  return correlationMatrix;
}

correlation_matrix = calculateCorrelationMatrix(data, selected_bivariate_cont_columns);
correlation_data = selected_bivariate_cont_columns.flatMap((col1, i) =>
  selected_bivariate_cont_columns.map((col2, j) => ({
    x: col1,
    y: col2,
    value: correlation_matrix[i][j]
  }))
);

Plot.plot({
  marks: [
    Plot.cell(correlation_data, {x: "x", y: "y", fill: "value", title: d => d.value.toFixed(2)}),
    Plot.text(correlation_data, {x: "x", y: "y", text: d => d.value.toFixed(2), dy: 0, textAnchor: "middle"})
  ],
  x: {
    domain: selected_bivariate_cont_columns,
    label: "Variables"
  },
  y: {
    domain: selected_bivariate_cont_columns,
    label: "Variables"
  },
  color: {
    type: "linear",
    scheme: "blues",
    label: "Correlation"
  },
  width: 600,
  height: 600
})


```

## What did you observe?

[fix comment for utteranc]{style="color:red;"}

<div class="utterances-comments">
{{< utterances-comments >}}
</div>

## Why is finding correlation and relationship analysis on features important?

[fix comment for utteranc]{style="color:red;"}

<div class="utterances-comments">
{{< utterances-comments >}}
</div>


## Why is finding correlation and relationship analysis on features important?

::: incremental
- **Music Production insights**: Knowing what is related to danceability let’s said makes music producer able to understand what makes a good music
- **Marketing & Promotion Strategies** : Knowsing what is the relationship between top performing songs and its features is important as it helps the platform to recommend same type fo songs for users in the future.
:::


# AI & EDA

## From Relationships to Decisions: Enter AI

::: incremental
- **Understanding Relationships**: Now that you know how to explore relationships in data, the next step is using AI to make decisions based on these insights.
- **Why AI is Needed**: 
  - **Scale**: AI can analyze vast amounts of data quickly, something humans can't do daily.
  - **Efficiency**: AI can identify patterns and trends in data automatically, enabling faster and more accurate decisions.
:::

## Example: AI in Action

::: incremental
  -  AI groups similar data points (like songs or users) without needing pre-labeled examples.
  - **Example 1**: Grouping songs by genre, mood, or tempo to create better recommendations without manual analysis.
  - **Example 2**: Spotify Wrap:
    - **How It Works**: AI analyzes your listening habits, clusters you with similar users, and creates personalized playlists.
    - **Benefits**: Tailored music recommendations, targeted ads, and a deeper understanding of user preferences.
:::


# Thank You!